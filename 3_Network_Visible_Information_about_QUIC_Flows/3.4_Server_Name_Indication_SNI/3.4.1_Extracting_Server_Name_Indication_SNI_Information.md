---
title: "3.4.1. 提取服务器名称（SNI）信息"
anchor: "3.4.1_Extracting_Server_Name_Indication_SNI_Information"
weight: 341
rank: "h3"
---

如果`ClientHello`未受到加密，那么就能够通过计算初始秘密值，解密数据包载荷，再解析包含着TLS `ClientHello`的QUIC**加密帧**的方式，分离出SNI。

由于初始秘密值的衍生和初始数据包本身的结构都是特定于版本的，因此第一步永远是解析版本号（长包头的第二至第五个字节）。
注意，只有长包头中带有版本号，所以有必要QUIC数据包的首个比特位是否被设置为`1`，它表示这是一个长包头。

注意，在标准化前部署的专有QUIC版本可能没有在QUIC长包头中将首个比特位设置为`1`。
不过，这些版本应该会随着时间逐渐消失，因此不需要任何特别考虑或特殊对待。

当版本被识别为QUIC版本1时，需要通过检查头部的第三个和第四个比特位是否均被设置为`0`的方式验证数据包类型是否为初始数据包。
随后，需要从数据包中提取目标连接ID。
初始秘密值的计算使用的是在《[QUIC-TLS](../RFC9001_Chinese_Simplified)》的[第5.2章](../RFC9001_Chinese_Simplified/#5.2_Initial_Secrets)中介绍的特定于版本的初始盐值。
头部的第6个字节表明了连接ID的长度，后面跟着连接ID。

注意，在后续的初始数据包中出现的目标连接ID可能不是用来创建初始秘密值的那个。
因此，尝试使用以上步骤来解密这些数据包的做法可能会失败，除非观察者一直保留着初始秘密值。

为了判断数据包头部的结束位置和载荷的起始位置，需要提取数据包号长度、源连接ID长度，还有令牌长度。
数据包号长度被定义为头部的第七个和第八个比特位，详见《[QUIC传输](../RFC9000_Chinese_Simplified)》的[第17.2章](../RFC9000_Chinese_Simplified/#17.2_Long_Header_Packets)，但它受到《[QUIC-TLS](../RFC9001_Chinese_Simplified)》的[第5.4章](../RFC9001_Chinese_Simplified/#5.4_Header_Protection)中所述的保护。
源连接ID长度是在目标连接ID后的那个字节中指定的。
令牌长度，它跟在源连接ID后面，是一个可变长度整型值，详见《[QUIC传输](../RFC9000_Chinese_Simplified)》的[第16章](../RFC9000_Chinese_Simplified/#16_Variable-Length_Integer_Encoding)。

经过解密，就能够解析客户端的初始数据包，从而检测含有TLS `ClientHello`的**加密帧**，可以像基于TCP的TLS连接的解析方法一样去解析它。
注意，可能有多个**加密帧**散布在一个或多个初始数据包中，并且它们可能不按顺序出现，所以需要解析偏移和长度以重新组装**加密帧**的流。
此外，客户端的初始数据包中好可能含有其他帧，所以需要检查每个帧的首个字节以识别帧类型，判断是否可以跳过该帧，注意，帧的长度取决于帧的类型；详见《[QUIC传输](../RFC9000_Chinese_Simplified)》的[第18章](../RFC9000_Chinese_Simplified/#18_Transport_Parameter_Encoding)。
例如，**填充帧**可能出现在**加密帧**的前面、后面，或夹在中间。
然而，扩展或许会定义额外的帧类型。
如果遇到了某个未知类型的帧，那么就不可能知道帧的长度，导致无法跳过该帧；因此，解析失败。
